https://github.com/Glimis/browser

# url请求发生了什么
- url验证与判断

    互联网是以url为请求地址的一种方式,而浏览器对输入框中的内容,又做了一层拓展

    对于属于浏览器输入框中的内容

    一种是url或类url,这种会由浏览器转换为标准的http协议,比如他会默认的追加http或者是https,当然具体的那种协议,与缓存有关

    针对url,也就是符合http协议的内容,走http协议部分

    一种是其他协议,那这种情况走的就是其他协议,比如JavaScript,base64,chrome等
    
    注:
    早期ie,输入地址必须http打全,否则404
- 事件 beforeunload
    不同于退出,执行不了alert系列

    只能做监听

- tcp准备

    http基于tcp协议,要进行http协议,首先是tcp链接,tco链接第一步是准备ip,mac和端口号,这里包括服务端的,也包括用户端的

    mac的准备可能是链路层进行,但是ip与端口号,则必须由浏览器准备
- DNS

    通过域名获取IP的流程,基本上就是浏览器缓存,本地host,DNS服务器缓存,跟级服务器,二级服务器

- http排队
    针对一域6个连接的限制 【君子协议,防服务器卡爆】

- tcp握手
    tcp开始基础,保证双方可以进行传输与接收

- http传输
    分传输与响应

    传输即http传输,在达到接收缓存值【64K】或 请求长度达到 【包括一次和多次】,都会产生响应

    根据包的大小[1.5K]和慢加速的特性

    传输本身的大小也包含了4k限制,16k限制和64k限制  【如js不要超过4k或16k的建议】
- 浏览器响应
    分沟通与处理/渲染两阶段

    当浏览器收到请求头信息的时候,会进入浏览器沟通阶段  【此时,网络可能还在传输】

    这个阶段主要是根据content-type去判断响应方式,比如收到text/html,拿在收到请求报文,会进入渲染流程,而收到字节流可能就会进入下载流程

    假设收到的是text/html,拿在接受请求报文后,记录url日志,这个时候算是进入了渲染流程,整个页面会进行初始化

    开始进入白屏阶段   【白屏前即卸载,会进入unload事件】

    而后开启渲染流程
- 触发渲染流程
    对于渲染流程,大方向就是渲染,绘制,合成【生成,组合与复用】
    
    而能够引起渲染流程的主要就是解析html,解析style以及js的动态生成

- rendering --> 渲染/重排  --> 生成
    解析html生成,会产生domcument  【类似ast,词法分析】

    解析根据css生成内存styleSheet --》 继承规则`与`层叠规则`，此处将各种相对(rm),语义化(bold,black)属性转换成绝对值  【类似ast】

    而后合并  【css选择器,从左往右 与 从右往左】
- painting --> 渲染流程
    根据是否显示,生成布局数 layout tree  【filter,去除display:none】

    根据层级关系,生成分层树 layer tree 【层,复用】

    根据图层进行绘制   【生成绘制指令】

    栅格化（raster）操作  --> 将绘制指令交给渲染进程   【一个像素三条指令,cpu/gpu执行】

    这里也会有gpu优化-->  GPU 栅格化  【图形学/gpu】

    合成  【图层复用】
    
    显示  【将内存中的数据,传给显示器,定时器/时钟/频率,前后缓冲区互换】


# chrome架构
- 单进程

浏览器最开始肯定是单进程，之后因为安全,性能等原因,进行了进程的划分

- 三进程
比如最经典的就是主进程与渲染进程的划分

渲染进程存在沙箱里,不能读取文件,不能获取操作系统的权限   【ie可使用activex,chrome使用插件,但插件也在沙箱内 --> 国企/电子狗/ie】

而主进程则用来下载资源,管理IPC,显示渲染进程生成的图片等等

再加上最容易崩溃的插件进程【也存在沙箱中】,这是浏览器经典的三进程的结构

渲染进程 + 沙箱【安全】

插件进程 + 沙箱【安全 + 稳定】

主进程 【全局维护】

- 五进程
将主进程中的gpu优化与网络提取出来

一个主进程,一个网络进程,一个gpu优化 + 多个渲染 + 多个插件

浏览器进程 : 管理 + 存储【本地操作】

    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能

渲染进程 :  Blink【webkit升级版】 + v8

    核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

GPU 进程

    其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

网络进程

    主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

插件进程 : 稳定性

    主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。


- 面向服务的架构
一个服务可以在一个进程里运行,已提供更好的性能和兼容性

如果配置不够,服务可以进行合并【进程公用】


注:
    iframe单独的进程


chrome浏览器地址 xxx,跨域可见

# 浏览器包含内容
- 加载
对浏览器而言,就是网络进程 【http1/http2】

对于api就是调用接口,对静态资源,使用指令/属性 【ajax,js/css】

对特殊情况则需要使用预/懒 【http加载优先级】

在特殊就是自定义加载优先级 【bigpipe】

- 渲染
重排,重绘,合成

- 存储
cookie  【跨域】

sessionstorage 【权限资源】 

localstorage 【本地资源】

indexdb 【富文本】
- 离线
service worker  【或依赖储存做离线,将B/S模拟为C/S】

- 连接
web socket

- 音频/视频
webrtc/Audio   【主要是平台兼容性】
