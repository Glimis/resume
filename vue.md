https://github.com/Glimis/vue-doc

# 描述
vue 的创始理念是`简单`

从`vue0.1/vue1`能明显的感受到这种态度,怎么方便怎么来

实现,就跟能想象到的一样,没有太多的概念

而react的创始理念是`不关注`并高效

## 不关注
对于jsp时期,通过table按钮进行删除,需要动态添改变table的内容

最早期的做法是删除,调用ajax后,`直接刷新页面`

直接刷新页面就是`不关注`,他复用了页面初始化的逻辑

类似的情况包括echart,hchart,jq组件,在我懒得更新的时候,我可以尝试修改`config`,并重新创建实例,达到刷新的目的

注:
这种不关心,也就是组件[理论上]不存在方法  【特指,自己不用,提供给二次开发人员进行调用】

比如vue中定义的methods,通常希望是会被内部消耗的

## 高效
无论是刷新页面还是组件重新实例化,都是低效的

最高效的方式一定是直接定位到具体的事件,而`直接定位`就是`关心`



## vue2 面向react 改变
vue2的核心是`跨平台`与`通用`

跨平台需要不依赖`view`,也就是vm不能再直接关联view   【vue 提供了 两种view关联】

需要一种解耦,而这种解耦的方式,最终指向了vdom

也就是,实现的概念上有了很大的重复   【虽然出发点不一样】


## 中间层 - component
不关心的核心概念就是刷新中间层`component`,也就是组件 【总不能刷新整个页面吧】

类似于`$.combox(el,config)`,在减少下拉属性后,修改config,在此调用`$.combox(el,config)`

区别在于,当`config`改变后自动修改,这也是`mvvm`与`mvc`最大的区别,即`主动触发`与`被动触发`

这里的核心问题就是如何创建/表达component  

1. 传统组件包含四大类,属性,方法,事件,模板   【参考各类jq组件的api】
2. 对模板的优化  
    传统组件,并不会过多处理模板  【模板只会被使用一次】
    而此时,由模板到实例化的优化,是性能优化最多的地方,包括
    - 模板转ast,并对ast进行闭包   【编译原理,由ast转换为dom,由ast做中间层】
    - 区分编译与运行 【html转ast只有一次,而ast转dom/vdom,会有多次】
    - ast产生vdom 【见下】
    - vdom打补丁,操作dom  【diff】
注:
render就是ast转vdom的函数,所有组件使用render,可以取消vue的编译过程

### 高效刷新 - vdom
component整个刷新/重新生成依然是低效的  【此处有分歧】

最高效的方式是比较不同,将全局刷新还原为关注细节的方式

有一种从结果逆推的方式,即生成config改变后的html,然后比较不同 【算法 - 比较字符串的不同】

生成不同变化的函数,然后执行函数即可

我们一般说的vdom,干的就是这事,vdom与不渲染的dom表现一致 【当然他有更多的拓展性,比如自定义标签】

注:所谓的vdom更加高效,是跟全局刷新对比的,跟`关注型`完全没有可比性

### 被动触发 - 依赖收集
config被修改了如何触发?`Object.defineProperties`,那触发后执行的是什么?

对于vue0.1,执行的是指令的变化,甚至是具体dom内容的改变 --》 vue0.1源码

而对于vue2的理念,触发的就是`component`的刷新

这里的问题是,如果一个组件,同一时间,两个属性都修改了,如何保证刷新一次  【算法 - 去重,异步】

异步,就有确保及时响应的问题  -- 【宏/微 任务,脏数据】

及时响应又存在微任务比原生事件更快,引起脏数据问题  -- 【nextTick,ios】

...

解决以上问题的机制,就是依赖收集

### other
当然,也包括其他问题

1. 纯静态资源优化  【理论不需要编译为ast】
2. 组件创建  【组件就是vue实例】
3. 组件交互 【eventBus】
4. 全局拓展  
5. 生命周期
...